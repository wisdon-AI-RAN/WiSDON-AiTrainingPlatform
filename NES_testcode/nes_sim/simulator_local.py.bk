import os
import time
from pathlib import Path
import numpy as np



from influxdb_client import InfluxDBClient, Point
from influxdb_client.client.write_api import SYNCHRONOUS

import ddpg_nes_allscen_lstm_8f_v22 as v22  # 依你檔名改


def load_local_env():
    """
    Load shared env vars from franz_v011/.env.local so simulator and app use the same settings.
    Keep OS environment overrides intact by only filling missing keys.
    """
    env_path = Path(__file__).resolve().parent.parent / "franz_v011" / ".env.local"
    if not env_path.exists():
        return

    for raw in env_path.read_text(encoding="utf-8").splitlines():
        line = raw.strip()
        if not line or line.startswith("#") or "=" not in line:
            continue
        key, _, value = line.partition("=")
        key = key.strip()
        if not key:
            continue
        os.environ.setdefault(key, value.strip())

    print(f"[SIM-LOCAL] Loaded env from {env_path}")


load_local_env()

# ---- Patch v22.decode_one_hot to CPU-only (avoid torch/cuda) ----

def decode_one_hot_cpu(one_hot_vector):
    """
    one_hot_vector: length 256 one-hot (numpy array)
    return: list[int] length TOTAL_BS=8 bits after role enforcement
    """
    vec = np.asarray(one_hot_vector).astype(np.float32).reshape(-1)
    idx = int(np.argmax(vec))  # 0..255

    # 8-bit binary string
    bits_str = format(idx, f"0{v22.TOTAL_BS}b")  # e.g. "01010101"

    # Assume MSB->RU0. If mapping is reversed in your original v22, flip it with [::-1]
    bits = [int(c) for c in bits_str]

    # Enforce roles if these lists exist in v22; otherwise treat as empty
    inactive = getattr(v22, "INACTIVE_RUS", [])
    coverage = getattr(v22, "COVERAGE_RUS", [])

    for ru in inactive:
        bits[ru] = 0
    for ru in coverage:
        bits[ru] = 1

    return bits

v22.decode_one_hot = decode_one_hot_cpu
print("[SIM-LOCAL] Patched v22.decode_one_hot -> CPU-only")


INFLUX_URL    = os.environ.get("INFLUX_URL", "http://127.0.0.1:8086")
INFLUX_TOKEN  = os.environ.get("INFLUX_TOKEN", "")
INFLUX_ORG    = os.environ.get("INFLUX_ORG", "my-org")
INFLUX_BUCKET = os.environ.get("INFLUX_BUCKET", "api_bucket")

RUN_ID  = os.environ.get("RUN_ID", "demo_run_001")
EPISODE = int(os.environ.get("EPISODE", "0"))

STEP_PERIOD_SEC = float(os.environ.get("STEP_PERIOD_SEC", "1.0"))
FALLBACK_ACTION_IDX = int(os.environ.get("FALLBACK_ACTION_IDX", "0"))
BEST_SEARCH_FLAG = int(os.environ.get("BEST_SEARCH_FLAG", "0"))
WAIT_FOR_ACTION_SEC = float(os.environ.get("WAIT_FOR_ACTION_SEC", "2.0"))

def influx_client():
    return InfluxDBClient(url=INFLUX_URL, token=INFLUX_TOKEN, org=INFLUX_ORG)

def write_points(client, points):
    client.write_api(write_options=SYNCHRONOUS).write(bucket=INFLUX_BUCKET, record=points)

def query_one_field_last(client, flux: str):
    tables = client.query_api().query(flux)
    for tb in tables:
        for rec in tb.records:
            return rec.get_value()
    return None

def flux_get_action_idx(run_id: str, episode: int, step: int) -> str:
    return f'''
from(bucket: "{INFLUX_BUCKET}")
  |> range(start: -30m)
  |> filter(fn: (r) => r._measurement == "nes_action")
  |> filter(fn: (r) => r.run_id == "{run_id}" and r.episode == "{episode}" and r.step == "{step}")
  |> filter(fn: (r) => r._field == "action_idx")
  |> last()
'''




def tensor_to_b64(arr: np.ndarray) -> str:
    import io, base64, gzip
    buf = io.BytesIO()
    np.save(buf, arr.astype(np.float32), allow_pickle=False)
    gz = gzip.compress(buf.getvalue())
    return base64.b64encode(gz).decode("ascii")

def make_onehot(action_idx: int, action_dim: int) -> np.ndarray:
    a = np.zeros((action_dim,), dtype=np.float32)
    a[action_idx] = 1.0
    return a

def main():
    client = influx_client()

    env = v22.Environment()
    state = env.reset()
    step = 0
    episode = EPISODE

    print(f"[SIM-LOCAL] INFLUX_URL={INFLUX_URL} ORG={INFLUX_ORG} BUCKET={INFLUX_BUCKET}")
    print(f"[SIM-LOCAL] RUN_ID={RUN_ID} EPISODE={episode} STEP_PERIOD_SEC={STEP_PERIOD_SEC}")
    print(f"[SIM-LOCAL] ACTION_DIM={v22.ACTION_DIM} TOTAL_BS={v22.TOTAL_BS}")

    while True:
        t0 = time.time()

        # 1) write state
        state_b64 = tensor_to_b64(np.asarray(state))
        p_state = (
            Point("nes_state")
            .tag("run_id", RUN_ID)
            .tag("episode", str(episode))
            .field("step", int(step))
            .field("state_b64", state_b64)
        )
        write_points(client, [p_state])

        # 2) read action_idx for this step (if inference already wrote it)
        action_idx = None
        deadline = time.time() + WAIT_FOR_ACTION_SEC  # allow worker some time to read & respond
        while time.time() < deadline:
            #print(flux_get_action_idx(RUN_ID, episode, step))

            action_idx = query_one_field_last(client, flux_get_action_idx(RUN_ID, episode, step))
            if action_idx is not None:
                break
            time.sleep(0.05)

        if action_idx is None:
            action_idx = FALLBACK_ACTION_IDX
        else:
            action_idx = int(action_idx)


        action_onehot = make_onehot(action_idx, v22.ACTION_DIM)

        # 3) step env
        next_state, reward, capacity, totalEnergy, bestReward, bestAction, bestCapacity, bestEnergy, done = env.step(
            state, action_onehot, BEST_SEARCH_FLAG
        )

        # 4) write transition
        next_state_b64 = tensor_to_b64(np.asarray(next_state))
        p_tr = (
            Point("nes_transition")
            .tag("run_id", RUN_ID)
            .tag("episode", str(episode))
            .field("step", int(step))
            .field("action_idx", int(action_idx))
            .field("reward", float(reward))
            .field("capacity", float(capacity))
            .field("energy", float(totalEnergy))
            .field("done", int(done))
            .field("state_b64", state_b64)
            .field("next_state_b64", next_state_b64)
        )
        write_points(client, [p_tr])

        # advance
        state = next_state
        step += 1
        
        if step % 10 == 0:
            print(f"[SIM-LOCAL] step={step} wrote state+transition, action_idx={action_idx}, reward={reward:.3f}, energy={totalEnergy:.3f}")


        if done:
            episode += 1
            step = 0
            state = env.reset()
            print(f"[SIM-LOCAL] episode -> {episode}")

        # pacing
        dt = time.time() - t0
        time.sleep(max(0.0, STEP_PERIOD_SEC - dt))

if __name__ == "__main__":
    main()
