"""Implementation of statechart task_queue.
Generated by itemis CREATE code generator.
"""

import sys, os
# sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../src')))
from controller.task_queue.src.yakindu.rx import Observable, TaskStartObserver, StopTrainingObserver, PushObserver, PushFailObserver
from controller.task_queue.src.yakindu.callback_func import CallBackFunc

class TaskQueue:
	"""Implementation of the state machine TaskQueue.
	"""

	class State:
		""" State Enum
		"""
		(
			task_queue_s2_waiting,
			task_queue_s0_idel,
			task_queue_s1_queuing,
			task_queue_s3_complete,
			null_state
		) = range(5)
	
	
	class AiTrPlatEvBuf:
		"""Implementation of internal scope.
		"""
		
		def __init__(self):
			self.task_complete = False
			self.push_in_task_queue = False
			self.delete_task_in_task_queue = False
	
	class TaskQueueEvBuf:
		"""Implementation of internal scope.
		"""
		
		def __init__(self, iface_ai_tr_plat):
			self.iface_ai_tr_plat = iface_ai_tr_plat
	
	class AiTrPlat:
		"""Implementation of scope AiTrPlat.
		"""
		
		def __init__(self, statemachine):
			self.num_task = None
			self.task_running = None
			self.app_status = None
			self.MAX_NUM_TASK = 10
			self.task_complete = None
			self.push_in_task_queue = None
			self.delete_task_in_task_queue = None
			self.task_start = None
			self.task_start_observable = Observable()
			self.task_start_observable.subscribe(TaskStartObserver())
			self.stop_training = None
			self.stop_training_observable = Observable()
			self.stop_training_observable.subscribe(StopTrainingObserver())
			self.push = None
			self.push_observable = Observable()
			self.push_observable.subscribe(PushObserver())
			self.push_fail = None
			self.push_fail_observable = Observable()
			self.push_fail_observable.subscribe(PushFailObserver())
			self.operation_callback = CallBackFunc()
			
			self.statemachine = statemachine
		
		def raise_task_complete(self):
			"""Raise method for event task_complete.
			"""
			self.task_complete = True
			
		def raise_push_in_task_queue(self):
			"""Raise method for event push_in_task_queue.
			"""
			self.push_in_task_queue = True
			
		def raise_delete_task_in_task_queue(self):
			"""Raise method for event delete_task_in_task_queue.
			"""
			self.delete_task_in_task_queue = True
			
	
	def __init__(self):
		""" Declares all necessary variables including list of states, histories etc. 
		"""
		self.ai_tr_plat = TaskQueue.AiTrPlat(self)
		
		# enumeration of all states:
		self.__State = TaskQueue.State
		self.__state_conf_vector_changed = None
		self.__state_vector = [None] * 1
		for __state_index in range(1):
			self.__state_vector[__state_index] = self.State.null_state
		
		# initializations:
		#Default init sequence for statechart TaskQueue
		self.ai_tr_plat.num_task = 0
		self.ai_tr_plat.task_running = False
		self.ai_tr_plat.app_status = False
		self.__current = self.TaskQueueEvBuf(
			self.AiTrPlatEvBuf()
		)
		self.__is_executing = False
	
	def is_active(self):
		"""Checks if the state machine is active.
		"""
		return self.__state_vector[0] is not self.__State.null_state
	
	def is_final(self):
		"""Checks if the statemachine is final.
		Always returns 'false' since this state machine can never become final.
		"""
		return False
			
	def is_state_active(self, state):
		"""Checks if the state is currently active.
		"""
		s = state
		if s == self.__State.task_queue_s2_waiting:
			return self.__state_vector[0] == self.__State.task_queue_s2_waiting
		if s == self.__State.task_queue_s0_idel:
			return self.__state_vector[0] == self.__State.task_queue_s0_idel
		if s == self.__State.task_queue_s1_queuing:
			return self.__state_vector[0] == self.__State.task_queue_s1_queuing
		if s == self.__State.task_queue_s3_complete:
			return self.__state_vector[0] == self.__State.task_queue_s3_complete
		return False
		
	def __enter_sequence_task_queue_s2_waiting_default(self):
		"""'default' enter sequence for state S2_Waiting.
		"""
		#'default' enter sequence for state S2_Waiting
		self.__state_vector[0] = self.State.task_queue_s2_waiting
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_task_queue_s0_idel_default(self):
		"""'default' enter sequence for state S0_IDEL.
		"""
		#'default' enter sequence for state S0_IDEL
		self.__state_vector[0] = self.State.task_queue_s0_idel
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_task_queue_s1_queuing_default(self):
		"""'default' enter sequence for state S1_Queuing.
		"""
		#'default' enter sequence for state S1_Queuing
		self.__state_vector[0] = self.State.task_queue_s1_queuing
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_task_queue_s3_complete_default(self):
		"""'default' enter sequence for state S3_Complete.
		"""
		#'default' enter sequence for state S3_Complete
		self.__state_vector[0] = self.State.task_queue_s3_complete
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_task_queue_default(self):
		"""'default' enter sequence for region TaskQueue.
		"""
		#'default' enter sequence for region TaskQueue
		self.__react_task_queue__entry_default()
		
	def __exit_sequence_task_queue_s2_waiting(self):
		"""Default exit sequence for state S2_Waiting.
		"""
		#Default exit sequence for state S2_Waiting
		self.__state_vector[0] = self.State.null_state
		
	def __exit_sequence_task_queue_s0_idel(self):
		"""Default exit sequence for state S0_IDEL.
		"""
		#Default exit sequence for state S0_IDEL
		self.__state_vector[0] = self.State.null_state
		
	def __exit_sequence_task_queue_s1_queuing(self):
		"""Default exit sequence for state S1_Queuing.
		"""
		#Default exit sequence for state S1_Queuing
		self.__state_vector[0] = self.State.null_state
		
	def __exit_sequence_task_queue_s3_complete(self):
		"""Default exit sequence for state S3_Complete.
		"""
		#Default exit sequence for state S3_Complete
		self.__state_vector[0] = self.State.null_state
		
	def __exit_sequence_task_queue(self):
		"""Default exit sequence for region TaskQueue.
		"""
		#Default exit sequence for region TaskQueue
		state = self.__state_vector[0]
		if state == self.State.task_queue_s2_waiting:
			self.__exit_sequence_task_queue_s2_waiting()
		elif state == self.State.task_queue_s0_idel:
			self.__exit_sequence_task_queue_s0_idel()
		elif state == self.State.task_queue_s1_queuing:
			self.__exit_sequence_task_queue_s1_queuing()
		elif state == self.State.task_queue_s3_complete:
			self.__exit_sequence_task_queue_s3_complete()
		
	def __react_task_queue__choice_0(self):
		"""The reactions of state null..
		"""
		#The reactions of state null.
		if self.ai_tr_plat.app_status:
			self.ai_tr_plat.task_running = False
			self.ai_tr_plat.stop_training_observable.next()
			self.__enter_sequence_task_queue_s3_complete_default()
		else:
			self.__enter_sequence_task_queue_s2_waiting_default()
		
	def __react_task_queue__choice_1(self):
		"""The reactions of state null..
		"""
		#The reactions of state null.
		if self.ai_tr_plat.num_task < self.ai_tr_plat.MAX_NUM_TASK:
			self.ai_tr_plat.num_task = self.ai_tr_plat.num_task + 1
			self.ai_tr_plat.push_observable.next()
			self.__enter_sequence_task_queue_s2_waiting_default()
		else:
			self.ai_tr_plat.push_fail_observable.next()
			self.__enter_sequence_task_queue_s2_waiting_default()
		
	def __react_task_queue__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.ai_tr_plat.num_task = 0
		self.ai_tr_plat.task_running = False
		self.ai_tr_plat.app_status = False
		self.__enter_sequence_task_queue_s0_idel_default()
		
	def __task_queue_s2_waiting_react(self, transitioned_before):
		"""Implementation of __task_queue_s2_waiting_react function.
		"""
		#The reactions of state S2_Waiting.
		transitioned_after = transitioned_before
		if transitioned_after < 0:
			if self.__current.iface_ai_tr_plat.task_complete:
				self.__exit_sequence_task_queue_s2_waiting()
				self.ai_tr_plat.task_running = False
				self.ai_tr_plat.num_task = self.ai_tr_plat.num_task - 1
				self.__enter_sequence_task_queue_s3_complete_default()
				transitioned_after = 0
			elif self.__current.iface_ai_tr_plat.delete_task_in_task_queue:
				self.__exit_sequence_task_queue_s2_waiting()
				self.ai_tr_plat.num_task = self.ai_tr_plat.num_task - 1
				self.ai_tr_plat.app_status = self.ai_tr_plat.operation_callback.get_app_status()
				self.__react_task_queue__choice_0()
				transitioned_after = 0
			elif self.__current.iface_ai_tr_plat.push_in_task_queue:
				self.__exit_sequence_task_queue_s2_waiting()
				self.__react_task_queue__choice_1()
				transitioned_after = 0
		#If no transition was taken
		if transitioned_after == transitioned_before:
			#then execute local reactions.
			transitioned_after = transitioned_before
		return transitioned_after
	
	
	def __task_queue_s0_idel_react(self, transitioned_before):
		"""Implementation of __task_queue_s0_idel_react function.
		"""
		#The reactions of state S0_IDEL.
		transitioned_after = transitioned_before
		if transitioned_after < 0:
			if self.__current.iface_ai_tr_plat.push_in_task_queue:
				self.__exit_sequence_task_queue_s0_idel()
				self.ai_tr_plat.num_task = self.ai_tr_plat.num_task + 1
				self.ai_tr_plat.push_observable.next()
				self.__enter_sequence_task_queue_s1_queuing_default()
				transitioned_after = 0
		#If no transition was taken
		if transitioned_after == transitioned_before:
			#then execute local reactions.
			transitioned_after = transitioned_before
		return transitioned_after
	
	
	def __task_queue_s1_queuing_react(self, transitioned_before):
		"""Implementation of __task_queue_s1_queuing_react function.
		"""
		#The reactions of state S1_Queuing.
		transitioned_after = transitioned_before
		if transitioned_after < 0:
			if not self.ai_tr_plat.task_running:
				self.__exit_sequence_task_queue_s1_queuing()
				self.ai_tr_plat.task_running = True
				self.ai_tr_plat.task_start_observable.next()
				self.__enter_sequence_task_queue_s2_waiting_default()
				transitioned_after = 0
		#If no transition was taken
		if transitioned_after == transitioned_before:
			#then execute local reactions.
			transitioned_after = transitioned_before
		return transitioned_after
	
	
	def __task_queue_s3_complete_react(self, transitioned_before):
		"""Implementation of __task_queue_s3_complete_react function.
		"""
		#The reactions of state S3_Complete.
		transitioned_after = transitioned_before
		if transitioned_after < 0:
			if self.ai_tr_plat.num_task <= 0:
				self.__exit_sequence_task_queue_s3_complete()
				self.ai_tr_plat.num_task = 0
				self.__enter_sequence_task_queue_s0_idel_default()
				transitioned_after = 0
			elif self.ai_tr_plat.num_task > 0:
				self.__exit_sequence_task_queue_s3_complete()
				self.__enter_sequence_task_queue_s1_queuing_default()
				transitioned_after = 0
		#If no transition was taken
		if transitioned_after == transitioned_before:
			#then execute local reactions.
			transitioned_after = transitioned_before
		return transitioned_after
	
	
	def __swap_in_events(self):
		"""Implementation of __swap_in_events function.
		"""
		self.__current.iface_ai_tr_plat.task_complete = self.ai_tr_plat.task_complete
		self.ai_tr_plat.task_complete = False
		self.__current.iface_ai_tr_plat.push_in_task_queue = self.ai_tr_plat.push_in_task_queue
		self.ai_tr_plat.push_in_task_queue = False
		self.__current.iface_ai_tr_plat.delete_task_in_task_queue = self.ai_tr_plat.delete_task_in_task_queue
		self.ai_tr_plat.delete_task_in_task_queue = False
	
	
	def __clear_in_events(self):
		"""Implementation of __clear_in_events function.
		"""
		self.ai_tr_plat.task_complete = False
		self.ai_tr_plat.push_in_task_queue = False
		self.ai_tr_plat.delete_task_in_task_queue = False
	
	
	def __micro_step(self):
		"""Implementation of __micro_step function.
		"""
		state = self.__state_vector[0]
		if state == self.State.task_queue_s2_waiting:
			self.__task_queue_s2_waiting_react(-1)
		elif state == self.State.task_queue_s0_idel:
			self.__task_queue_s0_idel_react(-1)
		elif state == self.State.task_queue_s1_queuing:
			self.__task_queue_s1_queuing_react(-1)
		elif state == self.State.task_queue_s3_complete:
			self.__task_queue_s3_complete_react(-1)
	
	
	def run_cycle(self):
		"""Implementation of run_cycle function.
		"""
		#Performs a 'run to completion' step.
		if self.ai_tr_plat.operation_callback is None:
			raise ValueError("Operation callback for interface AiTrPlat must be set.")
		
		if self.__is_executing:
			return
		self.__is_executing = True
		self.__swap_in_events()
		self.__micro_step()
		self.__is_executing = False
	
	
	def enter(self):
		"""Implementation of enter function.
		"""
		#Activates the state machine.
		if self.ai_tr_plat.operation_callback is None:
			raise ValueError("Operation callback for interface AiTrPlat must be set.")
		
		if self.__is_executing:
			return
		self.__is_executing = True
		#Default enter sequence for statechart TaskQueue
		self.__enter_sequence_task_queue_default()
		self.__is_executing = False
	
	
	def exit(self):
		"""Implementation of exit function.
		"""
		#Deactivates the state machine.
		if self.__is_executing:
			return
		self.__is_executing = True
		#Default exit sequence for statechart TaskQueue
		self.__exit_sequence_task_queue()
		self.__state_vector[0] = self.State.null_state
		self.__is_executing = False
	
	
