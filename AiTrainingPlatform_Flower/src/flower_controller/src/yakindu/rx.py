"""Implementation for Observer and Observables used for out events.
Generated by itemis CREATE code generator.
"""
import subprocess
import logging
import os
import threading
import requests

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# class Observer():
# 	"""Observer implementation.
# 	"""

# 	def next(self, value=None):
# 		"""Abstract next method, which must be implemented."""
# 		raise NotImplementedError('user must define next() to use this base class')
	
class StartFlowerAppObserver():
	"""Observer implementation.
	"""

	def next(self, value=None):
		"""Abstract next method, which must be implemented."""
		logger.info("start_flower_app command invoked.")
		def _run_flower_app():

			command = "flwr run app/network-energy-saving network_energy_saving --stream"
			logger.info("Launching Flower app in background: %s", command)
			try:
				exit_code = os.system(command)
				if exit_code == 0:
					logger.info("Flower app completed successfully.")
					controller_url = os.environ.get("CONTROLLER_API_URL", "http://localhost:9000/trigger_and_run")
					payload = {"event_name": "training_complete"}
					try:
						response = requests.post(controller_url, json=payload, timeout=10)
						if response.ok:
							logger.info("Raised 'training complete' event via controller API.")
						else:
							logger.error("Controller API returned %s: %s", response.status_code, response.text)
					except requests.RequestException as exc:
						logger.error("Unable to notify controller about training completion: %s", exc)
				else:
					logger.error("Flower app exited with code %s", exit_code)
			except OSError as exc:
				logger.error("Failed to execute Flower app: %s", exc)

		try:
			threading.Thread(target=_run_flower_app, daemon=True).start()
			logger.info("Flower app thread started.")
		except RuntimeError as exc:
			logger.error("Could not start Flower app thread: %s", exc)
	
class TerminateTrainingObserver():
	"""Observer implementation.
	"""

	def next(self, value=None):
		"""Abstract next method, which must be implemented."""
		logger.info("terminate_training command invoked.")
		def _terminate_training():
			command = "pkill -f 'flwr run'"
			logger.info("Attempting to terminate Flower training process: %s", command)
			try:
				exit_code = os.system(command)
				if exit_code == 0:
					logger.info("Training process terminated successfully.")
					controller_url = os.environ.get("CONTROLLER_API_URL", "http://localhost:9000/trigger_and_run")
					payload = {"event_name": "termination_complete"}
					try:
						response = requests.post(controller_url, json=payload, timeout=10)
						if response.ok:
							logger.info("Raised 'termination complete' event via controller API.")
						else:
							logger.error("Controller API returned %s: %s", response.status_code, response.text)
					except requests.RequestException as exc:
						logger.error("Unable to notify controller about training completion: %s", exc)
				else:
					logger.warning("Terminate command exited with code %s", exit_code)
			except OSError as exc:
				logger.error("Failed to terminate training process: %s", exc)

		try:
			threading.Thread(target=_terminate_training, daemon=True).start()
			logger.info("Termination thread started.")
		except RuntimeError as exc:
			logger.error("Could not start termination thread: %s", exc)
	
class CreateErrorLogObservableObserver():
	"""Observer implementation.
	"""

	def next(self, value=None):
		"""Abstract next method, which must be implemented."""
		logger.info("Create Error Log command invoked.")
	
class TaskCompleteObserver():
	"""Observer implementation.
	"""

	def next(self, value=None):
		"""Abstract next method, which must be implemented."""
		logger.info("Task Complete occurred.")
	
class TaskErrorObserver():
	"""Observer implementation.
	"""

	def next(self, value=None):
		"""Abstract next method, which must be implemented."""
		logger.info("Task Error occurred.")


class Observable():
	"""Observable implementation.
	"""

	def __init__(self):
		self.observers = []

	def next(self, value=None):
		"""Calls next function from every observer.
		"""
		for observer in self.observers:
			if observer is not None:
				if value is None:
					observer.next()
				else:
					observer.next(value)

	def subscribe(self, observer):
		"""Subscribe on specified observer.
		"""
		if observer is not None:
			self.observers.append(observer)
			return True
		return False

	def unsubscribe(self, observer):
		"""Unsubscribe from specified observer.
		"""
		if observer is None:
			return False
		if observer in self.observers:
			self.observers.remove(observer)
			return True
		return False
